#!/usr/bin/env python3

from typing import Generator, List, Tuple
from z3.z3 import And, BitVec, BitVecNumRef, BitVecRef, BitVecVal, LShR, Not, Solver, simplify, unsat, sat

wordsize = 32
N = 624
M = 397

def create_symbolic_state(name :str ="state") -> List[BitVecRef]:
    return [create_word_var(f"{name}[{i}]") for i in range(N)]

def create_word(value :int) -> BitVecNumRef:
    return BitVecVal(value, wordsize)

def create_word_var(name :str ="var"):
    return BitVec(name, wordsize)

def wordify(sample :int, sample_bits :int) -> Generator[Tuple[BitVecNumRef, int], None, None]:
    "takes a sample and its bitwidth and turns it into the words (and shifts) that were generated by the python random module"

    assert sample.bit_length() <= sample_bits, "provided sample is longer than possible with provided bitsize"
    mask_word = (1<<wordsize)-1
    sample_words = (sample_bits+wordsize-1)//wordsize
    discarded_bits = sample_words*wordsize - sample_bits
    lastwordshift = sample_words*wordsize - wordsize

    for shift in range(0, sample_words*wordsize, wordsize):
        value = create_word( (sample >> shift) & mask_word )

        if shift != lastwordshift:
            yield value, 0
        
        else:
            # least significant bits of the last word are discarded
            # see https://github.com/python/cpython/blob/main/Modules/_randommodule.c#L499
            yield value, discarded_bits

def harden(x :BitVecRef):
    """
    hardens a state value, turning is into a value returned by the PRNG
    see https://github.com/python/cpython/blob/main/Modules/_randommodule.c#L149=
    """

    x ^= LShR(x, 11)
    x ^= (x << 7) & create_word(0x9d2c5680)
    x ^= (x << 15) & create_word(0xefc60000)
    x ^= LShR(x, 18)
    return x

def reverse_harden(value :BitVecRef, shift :int =0) -> Generator[BitVecNumRef, None, None]:
    "solves the reverse of the harden operation for a single word"

    assert value.size() <= wordsize

    s = Solver()
    var = create_word_var("x")
    s.add(LShR(harden(var), shift) == value)

    while s.check() == sat:
        solution = s.model().eval(var)
        yield solution
        s.add(var != solution)

def regen(old_state :List[BitVecRef], preserve :bool =True) -> List[BitVecRef]:
    """
    performs the regen operation on a provided state and returns the new regenerated state
    if preserve is set the old state will be copied
    see https://github.com/python/cpython/blob/main/Modules/_randommodule.c#L132=
    """

    MATRIX_A = create_word(0x9908b0df)
    UPPER_MASK, LOWER_MASK = create_word(0x80000000), create_word(0x7fffffff)

    new_state = old_state[:] if preserve else old_state

    for kk in range(N-M):
        y = (new_state[kk]&UPPER_MASK)|(new_state[kk+1]&LOWER_MASK)
        new_state[kk] = simplify( new_state[  kk+M] ^ LShR(y, 1) ^ ((y & 1)*MATRIX_A) )

    for kk in range(N-M, N-1):
        y = (new_state[kk]&UPPER_MASK)|(new_state[kk+1]&LOWER_MASK)
        new_state[kk] = simplify( new_state[kk+(M-N)] ^ LShR(y, 1) ^ ((y & 1)*MATRIX_A) )

    y = (new_state[N-1]&UPPER_MASK)|(new_state[0]&LOWER_MASK)
    new_state[N-1] = simplify( new_state[M-1] ^ LShR(y, 1) ^ ((y & 1)*MATRIX_A) )

    return new_state

def reverse_regen(state :List[BitVecRef], samples :List[BitVecNumRef]) -> Solver:
    "solves the reverse of the regeneration operation"

    solver = Solver()
    for sample,variable in zip(samples, state):
        solver.add(harden(variable) == sample)
    assert solver.check() != unsat, f"reverse_regen is unsat"
    return solver

def iter_solutions(solver :Solver, var :BitVecRef):
    solver.push()

    while solver.check() == sat:
        v = solver.model().eval(var)
        # can also be BitVecRef (which means unconstrained)
        if isinstance(v, BitVecNumRef):
            yield v
        else:
            return
        solver.add(var != v)

    solver.pop()


class RandSolverState():
    def __init__(self) -> None:
        self.variables = tuple(create_word_var(f"symvar[{i}]") for i in range(N))
        self.generation = 0
        self.current_state = [v for v in self.variables]
        self.index = 0

        self.solver = Solver()

    def add_bits(self, bitvalue :int, bitsize :int):
        assert bitsize < N*wordsize, "not supported yet"

        for value, shift in wordify(bitvalue, bitsize):
            if self.index == N:
                self.generation += 1
                self.index = 0
                self.current_state = regen(self.current_state)

            # this keeps the solver smaller as all uniquely solveable values are inserted directly
            if shift == 0:
                revset = {*reverse_harden(value, shift)}
                assert len(revset) == 1, "This should be solveable!"
                real_value = revset.pop()
                self.solver.add(self.current_state[self.index] == real_value)
            else:
                self.solver.add( LShR(harden(self.current_state[self.index]), shift) == value )
            self.index += 1
    
    def iter_solutions(self) -> Generator[Tuple[int,...], None, None]:
        assumptions = []
        
        while self.solver.check(*assumptions) == sat:
            model = self.solver.model()
            solution = tuple(model.eval(var, model_completion=True) for var in self.variables)

            try:
                solution = tuple(x.as_long() for x in solution)
                yield solution
            except AttributeError:
                # TODO handle uninterpreted variables gracefully
                return

            assumptions.append( Not(And(*(v==s for v,s in zip(self.variables, solution)))) )

    def solve(self) -> Tuple[int,...]:
        solutions = [*self.iter_solutions()]
        assert len(solutions) == 1, "state is still ambiguous"
        return solutions[0]

    def solve_to_starting_module_state(self):
        return (3, self.solve()+(0,), None) 

    def solve_to_current_module_state(self):
        state = self.solve()
        for _ in range(self.generation):
            state = tuple(x.as_long() for x in regen(list(state)))
        return (3, state+(self.index,), None)

    def has_unique_solution(self) -> bool:

        assert self.solver.check() == sat
        model = self.solver.model()
        solution = tuple(model.eval(var) for var in self.variables)
        uninterpreted = [var for var in solution if not isinstance(var, BitVecNumRef)]

        if uninterpreted:
            # uninterpreted variables make this very very slow, an estimation is enough
            # TODO find out how to handle this correctly
            return False

        if self.solver.check( Not(And(*(v==s for v,s in zip(self.variables, solution)))) ) != sat:
            return True
        return False


if __name__ == "__main__":
    # configure me
    seeds = [108753, 860255]
    #partial_sizes = [wordsize*N-1, wordsize*N-2, wordsize*N-5]
    partial_sizes = [4095]

    import random

    for seed in seeds:
        for partial_bitsize in partial_sizes:
            partial_bytesize = (partial_bitsize+7)//8
            print(f"▶ testing partial {partial_bitsize} bit feed with seed '{seed}'")
            random.seed(seed)
            # state starts off at index 624 -> regnerate it by querying some items
            samples = [random.getrandbits(32) for _ in range(6)]
            #print(" ".join(f"sample[{i}]:{v:#10x}" for i,v in enumerate(samples)))
            real_module_state = random.getstate()
            real_state = random.getstate()[1][:N]
            #print(f"real state: {real_state[:6]} ... {real_state[-6:]}")
            random.seed(seed)

            rs_state = RandSolverState()
            for _ in range(0, N*32, partial_bytesize*8):
                rs_state.add_bits(random.getrandbits(partial_bitsize), partial_bitsize)

            while not rs_state.has_unique_solution():
                num_sol = rs_state.has_unique_solution()
                rs_state.add_bits(random.getrandbits(partial_bitsize), partial_bitsize)

            solutions = [*rs_state.iter_solutions()]
            assert len(solutions) == 1, "solution is not unique"
            for i, (sol, real) in enumerate(zip(solutions[0], real_state)):
                assert sol == real, f"solution[{i:3}]:{sol:#10x} ≠ {real:#10x}:real[{i:3}]"

            samplesize = 10

            samples = [random.getrandbits(partial_bitsize) for _ in range(samplesize)]
            random.setstate(rs_state.solve_to_current_module_state())
            reproduced_samples = [random.getrandbits(partial_bitsize) for _ in range(samplesize)]
            assert all(sample == reproduced for sample,reproduced in zip(samples, reproduced_samples)), "state export seems to not work"

            random.seed(seed)
            samples = [random.getrandbits(partial_bitsize) for _ in range(samplesize)]
            random.setstate(rs_state.solve_to_starting_module_state())
            reproduced_samples = [random.getrandbits(partial_bitsize) for _ in range(samplesize)]
            assert all(sample == reproduced for sample,reproduced in zip(samples, reproduced_samples)), "starting state export seems to not work"


        print(f"▶ testing full information with seed '{seed}'")
        random.seed(seed)
        samples = [create_word(random.getrandbits(wordsize)) for _ in range(N)]
        real_state = [create_word(x) for x in random.getstate()[1][:N]]
        assert all(simplify(harden(state_value)) == sample for state_value, sample in zip(real_state, samples)), "prediction does not match sampled data"

        sym_state = create_symbolic_state()
        solver = reverse_regen(sym_state, samples)
        model = solver.model()

        rev_state = [model.eval(v) for v in sym_state]
        assert all(rev == real for rev, real in zip(rev_state, real_state)), "state could not be recovered"

        new_samples = [create_word(random.getrandbits(wordsize)) for _ in range(N)]
        new_real_state = [create_word(x) for x in random.getstate()[1][:N]]
        assert all(simplify(harden(state_value)) == sample for state_value, sample in zip(new_real_state, new_samples)), "prediction does not match sampled data with new state"

        regen_state = regen(real_state)
        assert all(regenv == realv for regenv,realv in zip(regen_state, new_real_state)), "regen does not model real regen correctly"

        print()
