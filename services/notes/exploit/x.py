#!python3

import sys, secrets, random

from random_solve import RandSolverState
import pwn

prompt = b"> "

try:
    addr = sys.argv[1]
    port = sys.argv[2]
except IndexError:
    addr = "localhost"
    port = 1338

try:
    target_title = sys.argv[3]
except IndexError:
    target_title = None

def generate_random_element(g :int, p :int):
    return pow(g, secrets.randbelow(p-1), p)

def receive_parameter(remote, name :str):
    remote.recvuntil(f"{name}=".encode())
    return int(remote.recvuntil(b" ").decode(), 16)

def extract_challenge(remote, target_title) -> int:
    remote.sendline(f"read {target_title}".encode())

    # <-- [r]
    remote.sendline(f"{generate_random_element(g, p):x}".encode())

    # --> c
    remote.recvuntil(b"-->")
    challenge = int(remote.recvline(keepends=False), 16)

    # <-- s
    remote.sendline(f"{generate_random_element(g, p):x}".encode())
    remote.recvuntil(prompt)

    return challenge


with pwn.remote(addr, port) as remote:
    # ===== gather public parameters
    g = receive_parameter(remote, "g")
    p = receive_parameter(remote, "p")
    q = p.bit_length()-1
    print(f"▶ g={g:#x} p=({p.bit_length()}-bit prime)")
    remote.recvuntil(prompt)

    if target_title is None:
        remote.sendline(b"ls")
        files = remote.recvuntil(prompt, drop=True).decode()
        files = files.split("\n")[:-1]

        print("┏")
        for i, file in enumerate(files):
            print(f"┃{i} {file}")
        target_title = files[int(input("┗"))]

    # ===== gather samples
    solver_state = RandSolverState()

    bits_per_run = q
    words_per_run =(bits_per_run+31)//32
    for _ in range(0, 624, words_per_run):
        c = extract_challenge(remote, target_title)
        print(f"adding {bits_per_run} bits")
        solver_state.add_bits(c, bits_per_run)

    while not solver_state.has_unique_solution():
        print(f"adding {bits_per_run} more bits")
        solver_state.add_bits(extract_challenge(remote, target_title), bits_per_run)

    random.setstate(solver_state.solve_to_current_module_state())
    next_challenge = random.getrandbits(bits_per_run)
    
    print(f"▷ c={next_challenge:#x}")

    # ===== exploit
    remote.sendline(f"read {target_title}".encode()) 
    remote_y = receive_parameter(remote, "y")
    # calculate [r] s.t. [s] == [r]*y^c % p
    s = 1337  # s ∈ [0, q) !!!
    y_pow_c = pow(remote_y, next_challenge, p)
    t = (pow(y_pow_c, -1, p) * pow(g, s, p)) % p

    print(f"<--[r] = t")
    remote.recvuntil(b"<--")
    remote.sendline(f"{t:#x}".encode())

    print(f"--> c")
    remote.recvuntil(b"-->")
    c = int(remote.recvline(keepends=False), 16)
    assert c == next_challenge, f"✗ next challenge prediction was wrong!\nprediction={next_challenge:#x}\nactual={c:#x}"
    print(f"✓ next challenge prediction was correct")
    assert pow(g, s, p) == (t * pow(remote_y, c, p)) % p, "s will not verify"

    print(f"<-- s")
    remote.recvuntil(b"<--")
    remote.sendline(f"{s:#x}".encode())

    confirm = remote.recvline().decode()
    if "fail" in confirm:
        print(f"✗ {confirm}")

    remote.recvline()
    flag = remote.recvuntil(b"\n\n"+prompt, drop=True).decode()
    print(flag)
